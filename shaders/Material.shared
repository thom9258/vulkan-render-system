#define MAX_POINTLIGHTS 10
#define MAX_SPOTLIGHTS 10
#define MAX_DIRECTIONALLIGHTS 10
#define SHININESS 32

struct VertexOut
{
	vec2 texcoord;
	vec3 vertex_normal;
	vec3 fragpos;
	vec3 view_position;
	vec4 dirshadowcaster_fragpos_lightspace;
};

struct DirectionalLight
{
	vec3 direction;
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
};	

struct PointLight
{
	vec3 position;
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	vec3 attenuation;
	// attenuation.x = constant
	// attenuation.y = linear
	// attenuation.z = quadratic
};	

struct SpotLight
{
	vec3 position;
	vec3 direction;
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	vec3 attenuation;
	// attenuation.x = constant
	// attenuation.y = linear
	// attenuation.z = quadratic
	vec2 cutoff;
	// cutoff.x = inner
	// cutoff.y = outer
};




//TODO Make shadow calculation portable functions!
#if 0
bool is_in_directional_shadow(vec4 fragpos_lightspace)
{
	return false;
}

vec3 calculate_point_light(PointLight light)
{
    vec3 lightDir = normalize(light.position - frag_position);
    vec3 viewDir = normalize(view_position - frag_position);

    // diffuse shading
    vec3 normal = normalize(vertex_normal);
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS);

    // attenuation
    float distance = length(light.position - frag_position);
    float constant = light.attenuation.x;
    float linear = light.attenuation.y;
    float quadratic = light.attenuation.z;
    float attenuation = 1.0 / (constant + linear * distance + quadratic * (distance * distance));    

    // combine results
    vec3 ambient = light.ambient * vec3(texture(diffuse, texcoord));
    vec3 diffuse = light.diffuse * diff * vec3(texture(diffuse, texcoord));
    vec3 specular = light.specular * spec * vec3(texture(specular, texcoord));
    ambient *= attenuation;
    diffuse *= attenuation;
    specular *= attenuation;
	
	float normal_dot_length = dot(normal, lightDir);
	if (normal_dot_length > 0.0) 
		return (ambient + diffuse + specular);
	else
		return ambient;
}

vec3 calculate_directional_light(DirectionalLight light)
{
    vec3 lightDir = normalize(-light.direction);
    vec3 viewDir = normalize(view_position - frag_position);

    // diffuse shading
    vec3 normal = normalize(vertex_normal);
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS);

    // combine results
    vec3 ambient = light.ambient * vec3(texture(diffuse, texcoord));
    vec3 diffuse = light.diffuse * diff * vec3(texture(diffuse, texcoord));
    vec3 specular = light.specular * spec * vec3(texture(specular, texcoord));
	

	float normal_dot_length = dot(normal, lightDir);
	if (normal_dot_length > 0.0) 
		return (ambient + diffuse + specular);
	else
		return ambient;
}

vec3 calculate_spot_light(SpotLight light)
{
    vec3 lightDir = normalize(light.position - frag_position);
    vec3 viewDir = normalize(view_position - frag_position);

    // diffuse shading
    vec3 normal = normalize(vertex_normal);
    float diff = max(dot(normal, lightDir), 0.0);

    // specular shading
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS);

    // attenuation
    float distance = length(light.position - frag_position);
    float constant = light.attenuation.x;
    float linear = light.attenuation.y;
    float quadratic = light.attenuation.z;
    float attenuation = 1.0 / (constant + linear * distance + quadratic * (distance * distance));    
	
    // spotlight intensity
    float theta = dot(lightDir, normalize(-light.direction)); 
	const float inner_cutoff = light.cutoff.x;
	const float outer_cutoff = light.cutoff.y;
    float epsilon = inner_cutoff - outer_cutoff;
    float intensity = clamp((theta - outer_cutoff) / epsilon, 0.0, 1.0);

    // combine results
    vec3 ambient = light.ambient * vec3(texture(diffuse, texcoord));
    vec3 diffuse = light.diffuse * diff * vec3(texture(diffuse, texcoord));
    vec3 specular = light.specular * spec * vec3(texture(specular, texcoord));
    ambient *= attenuation * intensity;
    diffuse *= attenuation * intensity;
    specular *= attenuation * intensity;
	
	float normal_dot_length = dot(normal, lightDir);
	if (normal_dot_length > 0.0) 
		return (ambient + diffuse + specular);
	else
		return ambient;
}
#endif
